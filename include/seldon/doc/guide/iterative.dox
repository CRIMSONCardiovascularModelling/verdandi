/*! \file iterative.dox
    \brief Iterative Solvers.
*/

/*!
\page iterative Iterative Solvers

<h2>Syntax</h2>

<p>The syntax of all iterative solvers is the same </p>

<pre class="fragment">
int Gmres(const Matrix&amp; A, Vector&amp; x, const Vector&amp; b,
          Preconditioner&amp; M, Iteration&amp; iter);
</pre>


<p>The first argument <code>A</code> is the matrix to solve. The type of this argument is template, therefore you can provide your own class defining the matrix. The second and third argument are vectors, <code>x</code> contains the initial guess on input, the solution on output, <code>b</code> contains the right-hand-side. Again, the type of x and b is template, so you can have your own class to define the vectors. The fourth template argument is the preconditioner. For the moment, there is an implementation of the identity preconditioner (no preconditioning) and a SOR (Successive Over Relaxation) preconditioner. The last argument is a %Seldon structure defining the parameters of the iteration. The input matrix is assumed to be squared for all the iterative solvers.</p>


<h2>Basic use</h2>


<p> We provide an example of iterative resolution using %Seldon structures for the matrices and the vectors.</p>


\precode
// first we construct a sparse matrix
int n = 1000; // size of linear system
// we assume that you know how to fill arrays values, ptr, ind
Matrix<double, General, RowSparse< A(n, n, nnz, values, ptr, ind);

// then we declare vectors
Vector<double> b(n), x(n);

// you fill right-hand side and initial guess
b.Fill();
x.Fill(0);

// initialization of iteration parameters
int nb_max_iter = 1000;
// relative stopping criterion
double tolerance = 1e-6;
Iteration<double> iter(nb_max_iter, tolerance);

// identity preconditioner -> no preconditioning
Preconditioner_Base precond;

// then you can call an iterative solver, Cg for example
Cg(A, x, b, precond, iter);

// if you are using Gmres, you can set the restart parameter
// by default, this parameter is equal to 10
iter.SetRestart(5);
Gmres(A, x, b, precond, iter);
\endprecode


<h2>Advanced use</h2>


<p>Now, we will show an example where we construct a new class for a matrix that we don't store. If you want to test iterative solvers with that kind of strategy, you can take a look at the file test/program/iterative_test.cpp. The main thing to do is to overload the functions <a href="functions_blas.php#Mlt">Mlt</a> and <a href="functions_blas.php#MltAdd">MltAdd</a> that are called by iterative solvers to perform the matrix-vector product.</p>


\precode
// Class for a new type of matrix.
template<class T>
class BlackBoxMatrix
{
protected :
  // internal data used to represent the matrix
  int n;
  T beta;
  Seldon::Vector<T> lambda;
  
public :
  // basic constructor  
  BlackBoxMatrix(int n_, const T& beta_)
  {
    beta = beta_; n = n_;
    lambda.Reallocate(n);
    for (int i = 0; i < n; i++)
      lambda(i) = i+1;
  }
  
  // this method is used by iterative solvers
  // this should return the number of rows of the matrix
  int GetM() const
  {
    return n;
  }
  
};


// We need to define MltAdd(alpha, A, X, beta, Y) : Y <- beta Y + alpha A X
template<class T, class Vector>
void MltAdd(const T& alpha, const BlackBoxMatrix<T>& A,
	    const Vector& X, const T& beta, Vector& Y)
{
  if (beta == T(0))
    Y.Fill(T(0));
  else
    Mlt(beta, Y);
  
  int n = A.GetM();
  Vector C(X);
  // C = S^{-1} C
  for (int i = (n-2); i >= 0; i--)
    C(i) -= A.beta*C(i+1);
  
  // C = B C
  for (int i = 0; i < n; i++)
    C(i) *= A.lambda(i);
  
  // C = S C
  for (int i = 0; i < (n-1); i++)
    C(i) += A.beta*C(i+1);
  
  // Y = Y + alpha C
  Add(alpha, C, Y);
}


// and the transpose...
template<class T, class Vector>
void MltAdd(const T& alpha, const class_SeldonTrans& Trans,
	    const BlackBoxMatrix<T>& A,
	    const Vector& X, const T& beta, Vector& Y)
{
  if (beta == T(0))
    Y.Fill(T(0));
  else
    Mlt(beta, Y);
  
  int n = A.GetM();
  // Transpose of S B S^{-1} is S^{-t} B S^t
  Vector C(X);
  // Y = S^t Y
  for (int i = (n-1); i >= 1; i--)
    C(i) += A.beta*C(i-1);
  
  // Y = B Y
  for (int i = 0; i < n; i++)
    C(i) *= A.lambda(i);
  
  // Y = S^{-t} Y
  for (int i = 1; i < n; i++)
    C(i) -= A.beta*C(i-1);
  
  // Y = Y + alpha C
  Add(alpha, C, Y);
}


template<class T, class Vector>
void Mlt(const BlackBoxMatrix<T>& A, const Vector& X, Vector& Y)
{
  Y.Zero();
  MltAdd(T(1), A, X, T(0), Y);
}


template<class T, class Vector>
void Mlt(const class_SeldonTrans& Trans, const BlackBoxMatrix<T>& A,
	 const Vector& X, Vector& Y)
{
  Y.Zero();
  MltAdd(T(1), Trans, A, X, T(0), Y);
}

// class for preconditioning
template<class T>
class MyPreconditioner : public BlackBoxMatrix<T>
{
public : 
  
  MyPreconditioner(int n, T beta) : BlackBoxMatrix<T>(n, beta) { }  
  
  // solving M r = z
  template<class Matrix, class Vector>
  void Solve(const Matrix& A, const Vector& r, Vector& z)
  {
    Mlt(*this, r, z);
  }
  
  // solving transpose(M) r = z
  template<class Matrix, class Vector>
  void TransSolve(const Matrix& A, const Vector& r, Vector& z)
  {
    Mlt(SeldonTrans, *this, r, z);
  }
  
};

int main()
{
  // now it is very classical like the previous example
  int n = 20; double beta = 0.5;
  BlackBoxMatrix<double>; A(n, beta);
  Vector<double> b(n), x(n);
  
  // you fill right-hand side and initial guess
  b.Fill();
  x.Fill(0);
  
  // initialization of iteration parameters
  int nb_max_iter = 1000;
  double tolerance = 1e-6;
  Iteration<double> iter(nb_max_iter, tolerance);

  // your own preconditioner
  MyPreconditioner<double> precond(n, 1.2);
  
  // then you can call an iterative solver, Qmr for example
  Qmr(A, x, b, precond, iter);

  return 0;
}
\endprecode


<p>If you want to use your own class of vector, there are other functions to define : <a href="functions_blas.php#Add">Add</a>, <a href="functions_blas.php#Norm2">Norm2</a>, <a href="functions_blas.php#DotProd">DotProd</a>, <a href="functions_blas.php#DotProd">DotProdConj</a> , <a href="functions_blas.php#Copy">Copy</a> and the copy constructor. By default, three preconditioning are provided : Identity (Preconditioner_Base), SOR (SorPreconditioner) and incomplete factorisation (IlutPreconditioning). </p>


<h2>Methods of Preconditioner_Base:</h2>


<table class="category-table">
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#Solve"> Solve </a></td>
<td class="category-table-td"> Applies the preconditioner </td> </tr>
<tr class="category-table-tr-1">
 <td class="category-table-td"> <a href="#Solve">TransSolve</a></td>
<td class="category-table-td"> Applies the transpose of the preconditioner </td> </tr>
</table>


<h2>Methods of SorPreconditioner:</h2>


<table class="category-table">
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#InitSymmetricPreconditioning"> InitSymmetricPreconditioning</a></td>
<td class="category-table-td"> Symmetric SOR will be used </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#InitSymmetricPreconditioning"> InitUnSymmetricPreconditioning </a></td>
<td class="category-table-td"> SOR will be used </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#SetParameterRelaxation"> SetParameterRelaxation </a></td>
<td class="category-table-td"> changes the relaxation parameter </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#SetNumberIterations"> SetNumberIterations </a></td>
<td class="category-table-td"> changes the number of iterations </td> </tr>
<tr class="category-table-tr-2">
 <td class="category-table-td"> <a href="#sor_Solve"> Solve</a></td>
<td class="category-table-td"> Applies the preconditioner </td> </tr>
<tr class="category-table-tr-1">
 <td class="category-table-td"> <a href="#sor_Solve"> TransSolve</a></td>
<td class="category-table-td"> Applies the transpose of the preconditioner </td> </tr>
</table>


<h2>Methods of IlutPreconditioning :</h2>


<table class="category-table">
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#ilut_Clear"> Clear</a></td>
<td class="category-table-td"> clears memory used by incomplete factorisation </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetFactorisationType"> GetFactorisationType</a></td>
<td class="category-table-td"> returns the type of incomplete factorisation </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetFillLevel"> GetFillLevel </a></td>
<td class="category-table-td"> returns the fill-level k (if ILU(k) is set) </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetAdditionalFillNumber"> GetAdditionalFillNumber </a></td>
<td class="category-table-td"> returns the number of additional elements per row (used for ILUT(k))  </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetPrintLevel"> GetPrintLevel </a></td>
<td class="category-table-td"> returns the verbose level </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetPivotBlockInteger"> GetPivotBlockInteger </a></td>
<td class="category-table-td"> returns the maximum k = |i-j| allowed when pivoting </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#SetSymmetricAlgorithm"> SetSymmetricAlgorithm </a></td>
<td class="category-table-td"> sets symmetric incomplete factorisation </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#SetUnsymmetricAlgorithm"> SetUnsymmetricAlgorithm </a></td>
<td class="category-table-td"> sets unsymmetric incomplete factorisation (even for symmetric matrices) </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetFactorisationType"> SetFactorisationType</a></td>
<td class="category-table-td"> sets the type of incomplete factorisation </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetFillLevel"> SetFillLevel </a></td>
<td class="category-table-td"> sets the fill-level k (if ILU(k) is set) </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetAdditionalFillNumber"> SetAdditionalFillNumber </a></td>
<td class="category-table-td"> sets the number of additional elements per row (used for ILUT(k))  </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetPrintLevel"> SetPrintLevel </a></td>
<td class="category-table-td"> sets the verbose level </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetPivotBlockInteger"> SetPivotBlockInteger </a></td>
<td class="category-table-td"> sets the maximum k = |i-j| allowed when pivoting </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetDroppingThreshold"> GetDroppingThreshold </a></td>
<td class="category-table-td"> returns threshold to determine elements to drop </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetDroppingThreshold"> SetDroppingThreshold </a></td>
<td class="category-table-td"> sets threshold to determine elements to drop </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetDiagonalCoefficient"> GetDiagonalCoefficient </a></td>
<td class="category-table-td"> returns diagonal coefficient used in ILUD </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetDiagonalCoefficient"> SetDiagonalCoefficient </a></td>
<td class="category-table-td"> sets diagonal coefficient used in ILUD </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetPivotThreshold"> GetPivotThreshold </a></td>
<td class="category-table-td"> returns threshold used when pivoting columns </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetPivotThreshold"> SetPivotThreshold </a></td>
<td class="category-table-td"> sets threshold used when pivoting columns </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#FactorizeMatrix"> FactorizeMatrix </a></td>
<td class="category-table-td"> performs incomplete factorisation </td> </tr>
<tr class="category-table-tr-2">
 <td class="category-table-td"> <a href="#ilut_Solve"> Solve</a></td>
<td class="category-table-td"> Applies the preconditioner </td> </tr>
<tr class="category-table-tr-1">
 <td class="category-table-td"> <a href="#ilut_Solve"> TransSolve</a></td>
<td class="category-table-td"> Applies the transpose of the preconditioner </td> </tr>
</table>


<h2>Methods of Iteration:</h2>


<table class="category-table">
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#constructor">Constructors</a></td></tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetRestart">GetRestart</a></td>
<td class="category-table-td"> returns restart parameter </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetRestart">SetRestart</a></td>
<td class="category-table-td"> changes restart parameter </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetTolerance">GetTolerance</a></td>
<td class="category-table-td"> returns stopping criterion </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetTolerance">SetTolerance</a></td>
<td class="category-table-td"> changes stopping criterion </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#SetMaxIterationNumber">SetMaxIterationNumber</a></td>
<td class="category-table-td"> changes maximum number of iterations </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetNumberIteration">GetNumberIteration</a></td>
<td class="category-table-td"> returns iteration number </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetNumberIteration">SetNumberIteration</a></td>
<td class="category-table-td"> changes iteration number </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#messages">ShowMessages</a></td>
<td class="category-table-td"> displays residual each 100 iterations</td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#messages">HideMessages</a></td>
<td class="category-table-td"> displays nothing</td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#messages">ShowFullHistory</a></td>
<td class="category-table-td"> displays residual each iteration</td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#Init">Init</a></td>
<td class="category-table-td"> provides right hand side</td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#First">First</a></td>
<td class="category-table-td"> returns true for the first iteration</td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#SetInitGuess">IsInitGuess_Null</a></td>
<td class="category-table-td"> returns true if the initial guess is zero</td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#SetInitGuess">SetInitGuess</a></td>
<td class="category-table-td"> informs if the initial guess is zero or not</td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#Finished">Finished</a></td>
<td class="category-table-td"> returns true if the stopping criteria are satisfied</td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#Fail">Fail</a></td>
<td class="category-table-td"> informs that the iterative solver failed</td> </tr>
<tr class="category-table-tr-1">
 <td class="category-table-td"> <a href="#ErrorCode">ErrorCode</a></td>
<td class="category-table-td"> returns error code </td> </tr>
</table>


<h2><a name="solvers">Functions :</a></h2>


<table class="category-table">
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#SOR">SOR</a></td>
<td class="category-table-td"> Performs SOR iterations</td></tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#BiCg">BiCg</a></td>
<td class="category-table-td"> BIConjugate Gradient </td></tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#BiCgcr">BiCgcr</a></td>
<td class="category-table-td"> BIConjugate Gradient Conjugate Residual</td></tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#BiCgStab">BiCgStab</a></td>
<td class="category-table-td"> BIConjugate Gradient STABilized</td></tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#BiCgStabl">BiCgStabl</a></td>
<td class="category-table-td"> BIConjugate Gradient STABilized (L)</td></tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#Cg">Cg</a></td>
<td class="category-table-td"> Conjugate Gradient</td></tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#Cgne">Cgne</a></td>
<td class="category-table-td"> Conjugate Gradient Normal Equation</td></tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#Cgs">Cgs</a></td>
<td class="category-table-td"> Conjugate Gradient Squared</td></tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#CoCg">CoCg</a></td>
<td class="category-table-td"> Conjugate Orthogonal Conjugate Gradient</td></tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#Gcr">Gcr</a></td>
<td class="category-table-td"> Generalized Conjugate Residual</td></tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#Gmres">Gmres</a></td>
<td class="category-table-td"> Generalized Minimum RESidual</td></tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#Lsqr">Lsqr</a></td>
<td class="category-table-td"> Least SQuaRes</td></tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#MinRes">MinRes</a></td>
<td class="category-table-td"> Minimum RESidual</td></tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#QCgs">QCgs</a></td>
<td class="category-table-td"> Quasi Conjugate Gradient Squared</td></tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#Qmr">Qmr</a></td>
<td class="category-table-td"> Quasi Minimum Residual</td></tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#QmrSym">QmrSym</a></td>
<td class="category-table-td"> Quasi Minimum Residual SYMmetric</td></tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#Symmlq">Symmlq</a></td>
<td class="category-table-td"> SYMMetric Least sQuares</td></tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#TfQmr">TfQmr</a></td>
<td class="category-table-td"> Transpose Free Quasi Minimum Residual</td></tr>
</table>



<div class="separator"><a name="Solve"></a></div>



<h3>Solve, TransSolve for Preconditioner_Base</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void Solve(const Matrix&amp;, const Vector&amp;, Vector&amp;);
  void TransSolve(const Matrix&amp;, const Vector&amp;, Vector&amp;);
</pre>


<p>These methods should be overloaded if you want to define your own preconditioner since they define the application of the preconditioner or its transpose to a vector.</p>


<h4> Example : </h4>
\precode
// constructor of a matrix
int n = 20;
Matrix<double> A(n, n);
A.Fill();

// declaration of a preconditioner
Preconditioner_Base M;

// vectors
Vector<double> r(n), z(n);
r.Fill();

// now we apply preconditioning, i.e. solving M z = r
// for Preconditioner_Base, it will set z = r (identity preconditioner)
M.Solve(A, r, z);

// we can also apply the transpose of preconditioner
// i.e. solving transpose(M) z = r
M.TransSolve(A, r, z);

\endprecode


<h4>Location :</h4>
<p>Class Preconditioner_Base<br/>
Iterative.hxx<br/>
Iterative.cxx</p>



<div class="separator"><a name="sor_Solve"></a></div>



<h3>Solve, TransSolve for SorPreconditioner</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void Solve(const Matrix&amp;, const Vector&amp;, Vector&amp;);
  void TransSolve(const Matrix&amp;, const Vector&amp;, Vector&amp;);
</pre>


<p>These methods define the application of the preconditioner and its transpose to a vector. The used preconditioner is SOR (Successive Over Relaxation).  It can be used in its symmetric version (SSOR), or the unsymmetric version.  In this last case, the application of the preconditioner consists of a forward sweep while the transpose consists of a backward sweep. If you are using %Seldon structures of sparse matrices, the function <a href="#SOR">SOR</a> is available. If you are using other structures, it is necessary to overload the function SOR.</p>


<h4> Example : </h4>
\precode
// constructor of a matrix
int n = 20;
Matrix<double> A(n, n);
A.Fill();

// declaration of a preconditioner
SorPreconditioner<double> M;

// by default, relaxation parameter omega = 1
// number of iterations = 1
// you can change that
M.SetParameterRelaxation(1.5);
M.SetNumberIterations(2);

// if you prefer to use symmetric version
M.InitSymmetricPreconditioning();

// vectors
Vector<double> r(n), z(n);
r.Fill();

// now we apply preconditioning, i.e. solving M z = r
// for Preconditioner_Base, it will set z = r (identity preconditioner)
M.Solve(A, r, z);

// we can also apply the transpose of preconditioner
// i.e. solving transpose(M) z = r
M.TransSolve(A, r, z);

\endprecode


<h4>Related topics :</h4>
<p><a href="#SOR">SOR</a></p>

<h4>Location :</h4>
<p>Class SorPreconditioner<br/>
Precond_Ssor.cxx</p>



<div class="separator"><a name="InitSymmetricPreconditioning"></a></div>



<h3>InitSymmetricPreconditioning, InitUnSymmetricPreconditioning for SorPreconditioner</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void InitSymmetricPreconditioning();
  void InitUnsymmetricPreconditioning();
</pre>


<p><code>InitSymmetricPreconditioning</code> sets SSOR as preconditioning. The symmetric SOR consists of a forward sweep followed by a backward sweep. <code>InitUnSymmetricPreconditioning</code> sets SOR, it consists of a forward sweep for the preconditioner, and a backward sweep for the transpose of the preconditioner.</p>


<h4> Example : </h4>
\precode
// declaration of a preconditioner
SorPreconditioner<double> M;

// by default, symmetric preconditioning
// use InitUnSymmetricPreconditioning to force a non-symmetric preconditioning
M.InitUnSymmetricPreconditioning();
\endprecode


<h4>Related topics:</h4>
<p><a href="#SOR">SOR</a></p>


<h4>Location :</h4>
<p>Class SorPreconditioner<br/>
Precond_Ssor.cxx</p>



<div class="separator"><a name="SetParameterRelaxation"></a></div>



<h3>SetParameterRelaxation for SorPreconditioner</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetParameterRelaxation(const T&amp; omega);
</pre>


<p>This methods changes the relaxation parameter.</p>


<h4>Location :</h4>
<p>Class SorPreconditioner<br/>
Precond_Ssor.cxx</p>



<div class="separator"><a name="SetNumberIterations"></a></div>



<h3>SetNumberIterations for SorPreconditioner</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetNumberIterations(int);
</pre>


<p>This methods changes the number of SOR iterations.</p>


<h4>Location :</h4>
<p>Class SorPreconditioner<br/>
Precond_Ssor.cxx</p>



<div class="separator"><a name="ilut_Clear"></a></div>



<h3>Clear for IlutPreconditioning</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void Clear()
</pre>


<p>This methods clears the factorisation stored in the structure.</p>


<h4>Location :</h4>
<p>Class IlutPreconditioning<br/>
IlutPreconditioning.cxx</p>



<div class="separator"><a name="GetFactorisationType"></a></div>



<h3>GetFactorisationType for IlutPreconditioning</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  int GetFactorisationType() const
  void SetFactorisationType(int type)
</pre>


<p>These methods return (or set) the type of incomplete factorisation set. The following types of incomplete factorisation are available :</p>

<ul>
<li> ILUT : incomplete factorisation with threshold </li>
<li> ILU_D : incomplete factorisation with diagonal compensation </li>
<li> ILUT_K : incomplete factorisation with threshold </li>
<li> ILU_0 : incomplete factorisation on the same pattern as the original matrix </li>
<li> MILU_0 : incomplete factorisation on the same pattern as the original matrix with diagonal compensation </li>
<li> ILU_K : incomplete factorisation ILU(k) </li>
</ul>

\precode
// constructing a symmetric matrix
int n = 50;
Matrix<double, Symmetric, ArrayRowSymSparse> A(n, n);

// initialization of the preconditioning
IlutPreconditioning<double, double> ilut;

// type of incomplete factorisation
ilut.SetFactorisationType(ilut.ILU_K):
// for ILU_K, you need to set the fill level k
ilut.SetFillLevel(2);

// we want a symmetric preconditioning
ilut.SetSymmetricAlgorithm();

// then you can compute the incomplete factorisation
IVect permutation(n);
permutation.Fill();
ilut.FactorizeMatrix(permutation, A, true);

// and solve the linear system
Vector<double> x(n), b(n);
b.FillRand();
x.Zero();
Iteration<double> iter(1000, 1e-6);
Cg(A, x, b, ilut, iter);
\endprecode


<h4>Location :</h4>
<p>Class IlutPreconditioning<br/>
IlutPreconditioning.cxx</p>



<div class="separator"><a name="GetFillLevel"></a></div>



<h3>GetFillLevel, SetFillLevel for IlutPreconditioning</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  int GetFillLevel() const
  void SetFillLevel(int level);
</pre>


<p>These methods return (and set) the level k associated with ILU(k) factorisation. </p>

\precode
// constructing a symmetric matrix
int n = 50;
Matrix<double, Symmetric, ArrayRowSymSparse> A(n, n);

// initialization of the preconditioning
IlutPreconditioning<double, double> ilut;

// type of incomplete factorisation
ilut.SetFactorisationType(ilut.ILU_K):
// for ILU_K, you need to set the fill level k
ilut.SetFillLevel(2);

// we want a symmetric preconditioning
ilut.SetSymmetricAlgorithm();

// then you can compute the incomplete factorisation
IVect permutation(n);
permutation.Fill();
ilut.FactorizeMatrix(permutation, A, true);

// and solve the linear system
Vector<double> x(n), b(n);
b.FillRand();
x.Zero();
Iteration<double> iter(1000, 1e-6);
Cg(A, x, b, ilut, iter);
\endprecode

<h4>Location :</h4>
<p>Class IlutPreconditioning<br/>
IlutPreconditioning.cxx</p>



<div class="separator"><a name="GetAdditionalFillNumber"></a></div>



<h3>GetAdditionalFillNumber, SetAdditionalFillNumber for IlutPreconditioning</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  int GetAdditionalFillNumber() const
  void SetAdditionalFillNumber(int k)
</pre>


<p>These methods return (and set) the number of fill-in elements allowed per row during the factorisation. </p>


\precode
// constructing a symmetric matrix
int n = 50;
Matrix<double, Symmetric, ArrayRowSymSparse> A(n, n);

// initialization of the preconditioning
IlutPreconditioning<double, double> ilut;

// type of incomplete factorisation
ilut.SetFactorisationType(ilut.ILUT):
// for ILUT, you need to set the allowed additional fill-in elements
// for each row. If you put n, there will be no limit.
ilut.SetAdditionalFillNumber(n);
ilut.SetDroppingThreshold(0.01);

// we want a symmetric preconditioning
ilut.SetSymmetricAlgorithm();

// then you can compute the incomplete factorisation
IVect permutation(n);
permutation.Fill();
ilut.FactorizeMatrix(permutation, A, true);

// and solve the linear system
Vector<double> x(n), b(n);
b.FillRand();
x.Zero();
Iteration<double> iter(1000, 1e-6);
Cg(A, x, b, ilut, iter);
\endprecode

<h4>Location :</h4>
<p>Class IlutPreconditioning<br/>
IlutPreconditioning.cxx</p>



<div class="separator"><a name="GetPrintLevel"></a></div>



<h3>GetPrintLevel, SetPrintLevel for IlutPreconditioning</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  int GetPrintLevel() const
  void SetPrintLevel(int print_level)
</pre>


<p>These methods return (and set) the print level. </p>

\precode
// constructing a symmetric matrix
int n = 50;
Matrix<double, Symmetric, ArrayRowSymSparse> A(n, n);

// initialization of the preconditioning
IlutPreconditioning<double, double> ilut;

// type of incomplete factorisation
ilut.SetFactorisationType(ilut.ILU_K):
// for ILU_K, you need to set the fill level k
ilut.SetFillLevel(2);
// if you want messages to be displayed during factorisation
ilut.SetPrintLevel(2);

// we want a symmetric preconditioning
ilut.SetSymmetricAlgorithm();

// then you can compute the incomplete factorisation
IVect permutation(n);
permutation.Fill();
ilut.FactorizeMatrix(permutation, A, true);

// and solve the linear system
Vector<double> x(n), b(n);
b.FillRand();
x.Zero();
Iteration<double> iter(1000, 1e-6);
Cg(A, x, b, ilut, iter);
\endprecode


<h4>Location :</h4>
<p>Class IlutPreconditioning<br/>
IlutPreconditioning.cxx</p>



<div class="separator"><a name="GetPivotBlockInteger"></a></div>



<h3>GetPivotBlockInteger, SetPivotBlockInteger for IlutPreconditioning</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  int GetPivotBlockInteger() const
  void SetPivotBlockInteger(int k)
</pre>


<p>These methods return (and set) the maximal difference between diagonal index and pivot index allowed when pivoting. </p>

\precode
// constructing a non-symmetric matrix
int n = 50;
Matrix<double, General, ArrayRowSparse> A(n, n);

// initialization of the preconditioning
IlutPreconditioning<double, double> ilut;

// type of incomplete factorisation
ilut.SetFactorisationType(ilut.ILUT):
// pivot are searching within the block |i-j| <= k
// if you allow any pivot, put n
ilut.SetPivotBlockInteger(n);
ilut.SetPivotThreshold(0.1);
ilut.SetAdditionalFillNumber(n);
ilut.SetDroppingThreshold(0.01);

// then you can compute the incomplete factorisation
IVect permutation(n);
permutation.Fill();
ilut.FactorizeMatrix(permutation, A, true);

// and solve the linear system
Vector<double> x(n), b(n);
b.FillRand();
x.Zero();
Iteration<double> iter(1000, 1e-6);
Qmr(A, x, b, ilut, iter);
\endprecode

<h4>Location :</h4>
<p>Class IlutPreconditioning<br/>
IlutPreconditioning.cxx</p>



<div class="separator"><a name="GetDroppingThreshold"></a></div>



<h3>GetDroppingThreshold, SetDroppingThreshold for IlutPreconditioning</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  double GetDroppingThreshold() const
  void SetDroppingThreshold(double eps)
</pre>


<p>These methods return (and set) the dropping threshold. </p>

\precode
// constructing a non-symmetric matrix
int n = 50;
Matrix<double, General, ArrayRowSparse> A(n, n);

// initialization of the preconditioning
IlutPreconditioning<double, double> ilut;

// type of incomplete factorisation
ilut.SetFactorisationType(ilut.ILUT):
// pivot are searching within the block |i-j| <= k
// if you allow any pivot, put n
ilut.SetPivotBlockInteger(n);
ilut.SetPivotThreshold(0.1);
ilut.SetAdditionalFillNumber(n);
// threshold used to drop small values of the factorisation
ilut.SetDroppingThreshold(0.01);

// then you can compute the incomplete factorisation
IVect permutation(n);
permutation.Fill();
ilut.FactorizeMatrix(permutation, A, true);

// and solve the linear system
Vector<double> x(n), b(n);
b.FillRand();
x.Zero();
Iteration<double> iter(1000, 1e-6);
Qmr(A, x, b, ilut, iter);
\endprecode

<h4>Location :</h4>
<p>Class IlutPreconditioning<br/>
IlutPreconditioning.cxx</p>



<div class="separator"><a name="GetPivotThreshold"></a></div>



<h3>GetPivotThreshold, SetPivotThreshold for IlutPreconditioning</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  double GetPivotThreshold() const
  void SetPivotThreshold(double eps)
</pre>


<p>These methods return (and set) the pivot threshold. </p>

\precode
// constructing a non-symmetric matrix
int n = 50;
Matrix<double, General, ArrayRowSparse> A(n, n);

// initialization of the preconditioning
IlutPreconditioning<double, double> ilut;

// type of incomplete factorisation
ilut.SetFactorisationType(ilut.ILUT):
// pivot are searching within the block |i-j| <= k
// if you allow any pivot, put n
ilut.SetPivotBlockInteger(n);
// threshold used to determine if pivoting is needed
ilut.SetPivotThreshold(0.1);
ilut.SetAdditionalFillNumber(n);
// threshold used to drop small values of the factorisation
ilut.SetDroppingThreshold(0.01);

// then you can compute the incomplete factorisation
IVect permutation(n);
permutation.Fill();
ilut.FactorizeMatrix(permutation, A, true);

// and solve the linear system
Vector<double> x(n), b(n);
b.FillRand();
x.Zero();
Iteration<double> iter(1000, 1e-6);
Qmr(A, x, b, ilut, iter);
\endprecode

<h4>Location :</h4>
<p>Class IlutPreconditioning<br/>
IlutPreconditioning.cxx</p>



<div class="separator"><a name="GetDiagonalCoefficient"></a></div>



<h3>GetDiagonalCoefficient, SetDiagonalCoefficient for IlutPreconditioning</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  double GetDiagonalCoefficient() const
  void SetDiagonalCoefficient(double eps)
</pre>


<p>These methods return (and set) the coefficient used in the compensation of diagonal. </p>

\precode
// constructing a non-symmetric matrix
int n = 50;
Matrix<double, General, ArrayRowSparse> A(n, n);

// initialization of the preconditioning
IlutPreconditioning<double, double> ilut;

// type of incomplete factorisation
ilut.SetFactorisationType(ilut.ILU_D):
// pivot are searching within the block |i-j| <= k
// if you allow any pivot, put n
ilut.SetPivotBlockInteger(n);
// threshold used to determine if pivoting is needed
ilut.SetPivotThreshold(0.1);
ilut.SetAdditionalFillNumber(n);
// threshold used to drop small values of the factorisation
ilut.SetDroppingThreshold(0.01);
// diagonal compensation coefficient for ILU_D
ilut.SetDiagonalCoefficient(0.9);

// then you can compute the incomplete factorisation
IVect permutation(n);
permutation.Fill();
ilut.FactorizeMatrix(permutation, A, true);

// and solve the linear system
Vector<double> x(n), b(n);
b.FillRand();
x.Zero();
Iteration<double> iter(1000, 1e-6);
Qmr(A, x, b, ilut, iter);
\endprecode

<h4>Location :</h4>
<p>Class IlutPreconditioning<br/>
IlutPreconditioning.cxx</p>



<div class="separator"><a name="FactorizeMatrix"></a></div>



<h3>FactorizeMatrix for IlutPreconditioning</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void FactorizeMatrix(const Vector<int>& permut, Matrix&amp;);
  void FactorizeMatrix(const Vector<int>& permut, Matrix&amp;, bool keep_matrix);
</pre>


<p>This method performs the incomplete factorisation of the given matrix. By default, the matrix is cleared during the process. </p>

\precode
// constructing a non-symmetric matrix
int n = 50;
Matrix<double, General, ArrayRowSparse> A(n, n);

// initialization of the preconditioning
IlutPreconditioning<double, double> ilut;

// type of incomplete factorisation
ilut.SetFactorisationType(ilut.ILU_D):
// pivot are searching within the block |i-j| <= k
// if you allow any pivot, put n
ilut.SetPivotBlockInteger(n);
// threshold used to determine if pivoting is needed
ilut.SetPivotThreshold(0.1);
ilut.SetAdditionalFillNumber(n);
// threshold used to drop small values of the factorisation
ilut.SetDroppingThreshold(0.01);
// diagonal compensation coefficient for ILU_D
ilut.SetDiagonalCoefficient(0.9);

// then you can compute the incomplete factorisation
IVect permutation(n);
permutation.Fill();
// put true if you want to keep the original matrix
ilut.FactorizeMatrix(permutation, A, true);

// and solve the linear system
Vector<double> x(n), b(n);
b.FillRand();
x.Zero();
Iteration<double> iter(1000, 1e-6);
Qmr(A, x, b, ilut, iter);
\endprecode

<h4>Location :</h4>
<p>Class IlutPreconditioning<br/>
IlutPreconditioning.cxx</p>



<div class="separator"><a name="ilut_Solve"></a></div>



<h3>FactorizeMatrix for IlutPreconditioning</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void Solve(Vector&amp;)
  void TransSolve(Vector&amp;)
  void Solve(const Matrix&amp;, const Vector&amp;, Vector&amp;)
  void TransSolve(const Matrix&amp;, const Vector&amp;, Vector&amp;)
</pre>


<p>This method performs the approximate resolution of A x = b or A<sup>T</sup> x = b by using 
 the incomplete factorisation. </p>

\precode
// constructing a non-symmetric matrix
int n = 50;
Matrix<double, General, ArrayRowSparse> A(n, n);

// initialization of the preconditioning
IlutPreconditioning<double, double> ilut;

// type of incomplete factorisation
ilut.SetFactorisationType(ilut.ILU_K):
ilut.SetFillLevel(2);

// then you can compute the incomplete factorisation
IVect permutation(n);
permutation.Fill();
// put true if you want to keep the original matrix
ilut.FactorizeMatrix(permutation, A, true);

// and solve the linear system (Solve and TransSolve will be called by Qmr)
Vector<double> x(n), b(n);
b.FillRand();
x.Zero();
Iteration<double> iter(1000, 1e-6);
Qmr(A, x, b, ilut, iter);

// if you want to call Solve independently
x = b;
ilut.Solve(x);

\endprecode

<h4>Location :</h4>
<p>Class IlutPreconditioning<br/>
IlutPreconditioning.cxx</p>



<div class="separator"><a name="SetSymmetricAlgorithm"></a></div>



<h3>SetSymmetricAlgorithm for IlutPreconditioning</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetSymmetricAlgorithm() const
</pre>


<p>This methods informs to construct a symmetric preconditioning (if the given matrix is symmetric). </p>


\precode
// constructing a symmetric matrix
int n = 50;
Matrix<double, Symmetric, ArrayRowSymSparse> A(n, n);

// initialization of the preconditioning
IlutPreconditioning<double, double> ilut;

// we want a symmetric preconditioning
ilut.SetSymmetricAlgorithm();

// then you can compute the incomplete factorisation
IVect permutation(n);
permutation.Fill();
ilut.FactorizeMatrix(permutation, A, true);

// and solve the linear system
Vector<double> x(n), b(n);
b.FillRand();
x.Zero();
Iteration<double> iter(1000, 1e-6);
Cg(A, x, b, ilut, iter);
\endprecode

<h4>Location :</h4>
<p>Class IlutPreconditioning<br/>
IlutPreconditioning.cxx</p>


<div class="separator"><a name="SetUnsymmetricAlgorithm"></a></div>



<h3>SetUnsymmetricAlgorithm for IlutPreconditioning</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetUnsymmetricAlgorithm() const
</pre>


<p>This methods informs to construct an unsymmetric preconditioning (even if the given matrix is symmetric). </p>


\precode
// constructing a symmetric matrix
int n = 50;
Matrix<double, Symmetric, ArrayRowSymSparse> A(n, n);

// initialization of the preconditioning
IlutPreconditioning<double, double> ilut;

// we want a non-symmetric preconditioning
ilut.SetUnsymmetricAlgorithm();

// then you can compute the incomplete factorisation
IVect permutation(n);
permutation.Fill();
ilut.FactorizeMatrix(permutation, A, true);

// and solve the linear system
// with an iterative algorithm adpated to non-symmetric linear systems
Vector<double> x(n), b(n);
b.FillRand();
x.Zero();
Iteration<double> iter(1000, 1e-6);
BiCg(A, x, b, ilut, iter);
\endprecode

<h4>Location :</h4>
<p>Class IlutPreconditioning<br/>
IlutPreconditioning.cxx</p>



<div class="separator"><a name="constructor"></a></div>



<h3>Constructors for Iteration</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  Iteration();
  Iteration(int, const T&amp;);
</pre>


<p>The second constructor specifies the maximum number of iterations and the stopping criterion</p>


<h4>Location :</h4>
<p>Class Iteration<br/>
Iterative.hxx<br/>
Iterative.cxx</p>



<div class="separator"><a name="GetRestart"></a></div>



<h3>GetRestart, SetRestart for Iteration</h3>

<h4>Syntax :</h4>
 <pre class="syntax-box">
  int GetRestart();
  void SetRestart(int);
</pre>


<p>These methods give access to the restart parameter, which is used by some iterative solvers, e.g. BiCgSTAB(l), Gmres and Gcr.  The default value is equal to 10.</p>


<h4>Location :</h4>
<p>Class Iteration<br/>
Iterative.hxx<br/>
Iterative.cxx</p>



<div class="separator"><a name="GetTolerance"></a></div>



<h3>GetTolerance, SetTolerance for Iteration</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  T GetTolerance();
  void SetTolerance(T);
</pre>


<p>These methods give access to the stopping criterion.</p>


<h4>Location :</h4>
<p>Class Iteration<br/>
Iterative.hxx<br/>
Iterative.cxx</p>



<div class="separator"><a name="SetMaxIterationNumber"></a></div>



<h3>SetMaxIterationNumber for Iteration</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetMaxIterationNumber(int);
</pre>


<p>This method gives access to the maximum iteration number.</p>


<h4>Location :</h4>
<p>Class Iteration<br/>
Iterative.hxx<br/>
Iterative.cxx</p>



<div class="separator"><a name="GetNumberIteration"></a></div>



<h3>GetNumberIteration, SetNumberIteration for Iteration</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  int GetNumberIteration();
  void SetNumberIteration(int);
</pre>


<p>This method gives access to the iteration number.</p>


<h4>Location :</h4>
<p>Class Iteration<br/>
Iterative.hxx<br/>
Iterative.cxx</p>



<div class="separator"><a name="messages"></a></div>



<h3>ShowMessages, HideMessages, ShowFullHistory for Iteration</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void ShowMessages();
  void HideMessages();
  void ShowFullHistory();
</pre>


<p>If <code>ShowMessages</code> is called, it will display residual each 100 iterations during the resolution. If <code>HideMessages</code> is called, there is no display at all, whereas <code>ShowFullHistory</code> displays residual at each iteration.</p>


<h4>Location :</h4>
<p>Class Iteration<br/>
Iterative.hxx<br/>
Iterative.cxx</p>



<div class="separator"><a name="Init"></a></div>



<h3>Init for Iteration</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void Init(const Vector&amp;);
</pre>


<p>This method is used by iterative solvers to initialize the computation of residuals. Since relative residual is computed, we need to know the norm of the first residual.</p>


<h4>Location :</h4>
<p>Class Iteration<br/>
Iterative.hxx<br/>
Iterative.cxx</p>



<div class="separator"><a name="First"></a></div>



<h3>First for Iteration</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  bool First();
</pre>


<p>This method returns true for the first iteration.</p>


<h4>Location :</h4>
<p>Class Iteration<br/>
Iterative.hxx<br/>
Iterative.cxx</p>



<div class="separator"><a name="SetInitGuess"></a></div>



<h3>SetInitGuess, IsInitGuess_Null for Iteration </h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  bool IsInitGuess_Null();
  void SetInitGuess(bool);
</pre>


<p><code>SetInitGuess</code> allows you to inform the iterative solver that your initial guess is null. This can spare one matrix-vector product, which is good if the expected number of iterations is small.</p>


<h4>Example :</h4>
\precode
int n = 10;
Matrix<double> A(n, n);
Vector<double> x(n), b(n);
A.Fill();
b.Fill();

Iteration<double> iter(100, 1e-6);
// you inform that initial guess is null
iter.SetInitGuess(true);

// if the initial guess is null
// and x is non-null, the solver enforces x to be 0
Preconditioner_Base M;
Gmres(A, x, b, M, iter);

\endprecode


<h4>Location :</h4>
<p>Class Iteration<br/>
Iterative.hxx<br/>
Iterative.cxx</p>



<div class="separator"><a name="Finished"></a></div>



<h3>Finished for Iteration</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  bool Finished(const Vector&amp;);
</pre>


<p>This method is used by iterative solvers to know if the stopping criterion is reached. This method also displays the residual if required. </p>


<h4>Location :</h4>
<p>Class Iteration<br/>
Iterative.hxx<br/>
Iterative.cxx</p>



<div class="separator"><a name="Fail"></a></div>



<h3>Fail for Iteration</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  bool Fail(int, const string&amp;);
</pre>


<p>This method is used by iterative solvers when a breakdown occurs, often due to a division by 0. </p>


<h4>Location :</h4>
<p> Class Iteration<br/>
Iterative.hxx<br/>
Iterative.cxx</p>



<div class="separator"><a name="ErrorCode"></a></div>



<h3>ErrorCode for Iteration</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  int ErrorCode();
</pre>


<p>This method returns the error code after the resolution.  If the resolution has been successful, it should return 0. </p>


<h4>Location :</h4>
<p>Class Iteration<br/>
Iterative.hxx<br/>
Iterative.cxx</p>



<div class="separator"><a name="SOR"></a></div>



<h3>SOR</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SOR(const Matrix&amp;, Vector&amp;, const Vector&amp;, const T&amp;, int);
  void SOR(const Matrix&amp;, Vector&amp;, const Vector&amp;, const T&amp;, int, int);
</pre>


<p>This method tries to solve <code>A x = b</code> with n iterations of SOR. </p>


<h4>Example :</h4>
\precode
int n = 1000;
Matrix<double, General, RowSparse> A;
// you initialize A as you want (SetData for example)

// then vectors
Vector<double> x(n), b(n); 
x.Zero();
b.Fill();

// we want to solve A x = b
// 2 Sor iterations (forward sweep) with omega = 0.5
double omega = 0.5;
int nb_iterations = 2;
SOR(A, x, b, omega, nb_iterations);

// you can ask for symmetric SOR: forward sweeps followed
//                                by backward sweeps
SOR(A, x, b, omega, nb_iterations, 0);

// if you need backward sweep
SOR(A, x, b, omega, nb_iterations, 3);

\endprecode


<h4>Location :</h4>
<p>Relaxation_MatVect.cxx</p>



<div class="separator"><a name="BiCg"></a></div>



<h3>BiCg</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  int BiCg(const Matrix&amp;, Vector&amp;, const Vector&amp;,
           Preconditioner&amp;, Iteration&amp;);
</pre>


<p>This method tries to solve <code>A x = b</code> by using BICG algorithm.  This algorithm can solve complex general linear systems and calls matrix-vector products with the transpose matrix. </p>


<h4>Location :</h4>
<p>BiCg.cxx</p>



<div class="separator"><a name="BiCgcr"></a></div>



<h3>BiCgcr</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  int BiCgcr(const Matrix&amp;, Vector&amp;, const Vector&amp;,
             Preconditioner&amp;, Iteration&amp;);
</pre>


<p>This method tries to solve <code>A x = b</code> by using BICGCR algorithm.  This algorithm can solve symmetric complex linear systems. </p>


<h4>Location :</h4>
<p>BiCgcr.cxx</p>



<div class="separator"><a name="BiCgStab"></a></div>



<h3>BiCgStab</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  int BiCgStab(const Matrix&amp;, Vector&amp;, const Vector&amp;,
               Preconditioner&amp;, Iteration&amp;);
</pre>


<p>This method tries to solve <code>A x = b</code> by using BICGSTAB algorithm.  This algorithm can solve complex general linear systems and doesn't call matrix vector products with the transpose matrix. </p>


<h4>Location :</h4>
<p>BiCgStab.cxx</p>



<div class="separator"><a name="BiCgStabl"></a></div>



<h3>BiCgStabl</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  int BiCgStabl(const Matrix&amp;, Vector&amp;, const Vector&amp;,
                Preconditioner&amp;, Iteration&amp;);
</pre>


<p>This method tries to solve <code>A x = b</code> by using BICGSTAB(l) algorithm.  This algorithm can solve complex general linear systems and doesn't call matrix vector products with the transpose matrix. </p>


<h4>Location :</h4>
<p>BiCgStabl.cxx</p>



<div class="separator"><a name="Cg"></a></div>



<h3>Cg</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  int Cg(const Matrix&amp;, Vector&amp;, const Vector&amp;,
         Preconditioner&amp;, Iteration&amp;);
</pre>


<p>This method tries to solve <code>A x = b</code> by using CG algorithm.  This algorithm can solve real symmetric or hermitian linear systems. </p>


<h4>Location :</h4>
<p>Cg.cxx</p>



<div class="separator"><a name="Cgne"></a></div>



<h3>Cgne</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  int Cgne(const Matrix&amp;, Vector&amp;, const Vector&amp;,
           Preconditioner&amp;, Iteration&amp;);
</pre>


<p>This method tries to solve <code>A x = b</code> by using CGNE algorithm.  This algorithm can solve complex general linear systems and calls matrix vector products with the transpose matrix. </p>


<h4>Location :</h4>
<p>Cgne.cxx</p>



<div class="separator"><a name="Cgs"></a></div>



<h3>Cgs</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  int Cgs(const Matrix&amp;, Vector&amp;, const Vector&amp;,
          Preconditioner&amp;, Iteration&amp;);
</pre>


<p>This method tries to solve <code>A x = b</code> by using CGS algorithm.  This algorithm can solve complex general linear systems and doesn't call matrix vector products with the transpose matrix. </p>


<h4>Location :</h4>
<p>Cgs.cxx</p>



<div class="separator"><a name="CoCg"></a></div>



<h3>Cocg</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  int Cocg(const Matrix&amp;, Vector&amp;, const Vector&amp;,
           Preconditioner&amp;, Iteration&amp;);
</pre>


<p>This method tries to solve <code>A x = b</code> by using BICGSTAB algorithm.  This algorithm can solve complex symmetric linear systems. </p>


<h4>Location :</h4>
<p>CoCg.cxx</p>



<div class="separator"><a name="Gcr"></a></div>



<h3>Gcr</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  int Gcr(const Matrix&amp;, Vector&amp;, const Vector&amp;,
          Preconditioner&amp;, Iteration&amp;);
</pre>


<p>This method tries to solve <code>A x = b</code> by using BICGSTAB algorithm.  This algorithm can solve complex general linear systems and doesn't call matrix vector products with the transpose matrix. </p>


<h4>Location :</h4>
<p>Gcr.cxx</p>



<div class="separator"><a name="Gmres"></a></div>



<h3>Gmres</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  int Gmres(const Matrix&amp;, Vector&amp;, const Vector&amp;,
            Preconditioner&amp;, Iteration&amp;);
</pre>


<p>This method tries to solve <code>A x = b</code> by using restarted GMRES algorithm.  This algorithm can solve complex general linear systems and doesn't call matrix vector products with the transpose matrix. </p>


<h4>Location :</h4>
<p>Gmres.cxx</p>



<div class="separator"><a name="Lsqr"></a></div>



<h3>Lsqr</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  int Lsqr(const Matrix&amp;, Vector&amp;, const Vector&amp;,
           Preconditioner&amp;, Iteration&amp;);
</pre>


<p>This method tries to solve <code>A x = b</code> by using LSQR algorithm.  This algorithm can solve complex general linear systems and calls matrix vector products with the transpose matrix. </p>


<h4>Location :</h4>
<p>Lsqr.cxx</p>



<div class="separator"><a name="MinRes"></a></div>



<h3>MinRes</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  int MinRes(const Matrix&amp;, Vector&amp;, const Vector&amp;,
             Preconditioner&amp;, Iteration&amp;);
</pre>


<p>This method tries to solve <code>A x = b</code> by using BICGSTAB algorithm.  This algorithm can solve complex symmetric linear systems and doesn't call matrix vector products with the transpose matrix. </p>


<h4>Location :</h4>
<p>MinRes.cxx</p>



<div class="separator"><a name="QCgs"></a></div>



<h3>QCgs</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  int QCgs(const Matrix&amp;, Vector&amp;, const Vector&amp;,
           Preconditioner&amp;, Iteration&amp;);
</pre>


<p>This method tries to solve <code>A x = b</code> by using QCGS algorithm.  This algorithm can solve complex general linear systems and doesn't call matrix vector products with the transpose matrix. </p>


<h4>Location :</h4>
<p>QCgs.cxx</p>



<div class="separator"><a name="Qmr"></a></div>



<h3>Qmr</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  int Qmr(const Matrix&amp;, Vector&amp;, const Vector&amp;,
          Preconditioner&amp;, Iteration&amp;);
</pre>


<p>This method tries to solve <code>A x = b</code> by using QMR algorithm.  This algorithm can solve complex general linear systems and calls matrix vector products with the transpose matrix. </p>


<h4>Location :</h4>
<p>Qmr.cxx</p>



<div class="separator"><a name="QmrSym"></a></div>



<h3>QmrSym</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  int QmrSym(const Matrix&amp;, Vector&amp;, const Vector&amp;,
             Preconditioner&amp;, Iteration&amp;);
</pre>


<p>This method tries to solve <code>A x = b</code> by using symmetric QMR algorithm.  This algorithm can solve complex symmetric linear systems. </p>


<h4>Location :</h4>
<p> QmrSym.cxx</p>



<div class="separator"><a name="Symmlq"></a></div>



<h3>Symmlq</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  int Symmlq(const Matrix&amp;, Vector&amp;, const Vector&amp;,
             Preconditioner&amp;, Iteration&amp;);
</pre>


<p>This method tries to solve <code>A x = b</code> by using SYMMLQ algorithm.  This algorithm can solve complex symmetric linear systems. </p>


<h4>Location :</h4>
<p>Symmlq.cxx</p>



<div class="separator"><a name="TfQmr"></a></div>



<h3>TfQmr</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  int TfQmr(const Matrix&amp;, Vector&amp;, const Vector&amp;,
            Preconditioner&amp;, Iteration&amp;);
</pre>


<p>This method tries to solve <code>A x = b</code> by using TFQMR algorithm.  This algorithm can solve complex general linear systems and doesn't call matrix vector products with the transpose matrix. </p>


<h4>Location :</h4>
<p>TfQmr.cxx</p>

*/
